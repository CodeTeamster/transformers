#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨
#           This file was automatically generated from src/transformers/models/vit_rd/modular_vit_rd.py.
#               Do NOT edit this file manually as any edits will be overwritten by the generation of
#             the file from the modular. If any change should be done, please apply the change to the
#                          modular_vit_rd.py file directly. One of our CI enforces this.
#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨
# coding=utf-8
# Copyright 2025 the HuggingFace Team. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


import collections.abc
import math
import os
from typing import Callable, Optional, Union, List

import torch
from torch import nn

from ...activations import ACT2FN
from ...modeling_layers import GradientCheckpointingLayer
from ...modeling_outputs import (
    BaseModelOutput,
    BaseModelOutputWithPooling,
    ImageClassifierOutput,
    MaskedImageModelingOutput,
)
from ...modeling_utils import ALL_ATTENTION_FUNCTIONS, PreTrainedModel
from ...processing_utils import Unpack
from ...pytorch_utils import find_pruneable_heads_and_indices, prune_linear_layer
from ...utils import TransformersKwargs, auto_docstring, torch_int
from ...utils.generic import can_return_tuple, check_model_inputs
from .configuration_vit_rd import ViTRDConfig


class ViTRDEmbeddings(nn.Module):
    """
    Construct the CLS token, position and patch embeddings. Optionally, also the mask token.
    """

    def __init__(self, config: ViTRDConfig, use_mask_token: bool = False):
        super().__init__()

        self.patch_embeddings = ViTRDPatchEmbeddings(config)
        num_patches = self.patch_embeddings.num_patches + 1
        self.cls_token = nn.Parameter(torch.randn(1, 1, config.hidden_size))
        if hasattr(config, "supplement_token"):
            if isinstance(config.supplement_token, int) and config.supplement_token > 0:
                self.sup_token = nn.Parameter(
                    torch.randn(1, config.supplement_token, config.hidden_size)
                )
                num_patches += config.supplement_token
            elif config.supplement_token == 'layerwise1':
                self.sup_token = nn.Parameter(
                    torch.randn(1, config.num_hidden_layers, config.hidden_size)
                )
                num_patches += config.num_hidden_layers
            elif config.supplement_token == 'layerwise2':
                self.sup_token = nn.Parameter(
                    torch.randn(1, config.num_hidden_layers * 2, config.hidden_size)
                )
                num_patches += config.num_hidden_layers * 2
        self.mask_token = nn.Parameter(torch.zeros(1, 1, config.hidden_size)) if use_mask_token else None
        self.position_embeddings = nn.Parameter(
            torch.randn(1, num_patches, config.hidden_size)
        )
        self.dropout = nn.Dropout(config.hidden_dropout_prob)
        self.patch_size = config.patch_size
        self.config = config

    def interpolate_pos_encoding(self, embeddings: torch.Tensor, height: int, width: int) -> torch.Tensor:
        """
        This method allows to interpolate the pre-trained position encodings, to be able to use the model on higher resolution
        images. This method is also adapted to support torch.jit tracing.

        Adapted from:
        - https://github.com/facebookresearch/dino/blob/de9ee3df6cf39fac952ab558447af1fa1365362a/vision_transformer.py#L174-L194, and
        - https://github.com/facebookresearch/dinov2/blob/e1277af2ba9496fbadf7aec6eba56e8d882d1e35/dinov2/models/vision_transformer.py#L179-L211
        """

        num_patches = embeddings.shape[1] - 1
        num_positions = self.position_embeddings.shape[1] - 1

        # always interpolate when tracing to ensure the exported model works for dynamic input shapes
        if not torch.jit.is_tracing() and num_patches == num_positions and height == width:
            return self.position_embeddings

        class_pos_embed = self.position_embeddings[:, :1]
        patch_pos_embed = self.position_embeddings[:, 1:]

        dim = embeddings.shape[-1]

        new_height = height // self.patch_size
        new_width = width // self.patch_size

        sqrt_num_positions = torch_int(num_positions**0.5)
        patch_pos_embed = patch_pos_embed.reshape(1, sqrt_num_positions, sqrt_num_positions, dim)
        patch_pos_embed = patch_pos_embed.permute(0, 3, 1, 2)

        patch_pos_embed = nn.functional.interpolate(
            patch_pos_embed,
            size=(new_height, new_width),
            mode="bicubic",
            align_corners=False,
        )

        patch_pos_embed = patch_pos_embed.permute(0, 2, 3, 1).view(1, -1, dim)

        return torch.cat((class_pos_embed, patch_pos_embed), dim=1)

    def forward(
        self,
        pixel_values: torch.Tensor,
        bool_masked_pos: Optional[torch.BoolTensor] = None,
        interpolate_pos_encoding: bool = False,
    ) -> torch.Tensor:
        batch_size, num_channels, height, width = pixel_values.shape
        embeddings = self.patch_embeddings(pixel_values, interpolate_pos_encoding=interpolate_pos_encoding)

        if bool_masked_pos is not None:
            seq_length = embeddings.shape[1]
            mask_tokens = self.mask_token.expand(batch_size, seq_length, -1)
            # replace the masked visual tokens by mask_tokens
            mask = bool_masked_pos.unsqueeze(-1).type_as(mask_tokens)
            embeddings = embeddings * (1.0 - mask) + mask_tokens * mask

        # add the [CLS] token to the embedded patch tokens
        cls_tokens = self.cls_token.expand(batch_size, -1, -1)
        if hasattr(self, "sup_token"):
            sup_tokens = self.sup_token.expand(batch_size, -1, -1)
            embeddings = torch.cat((cls_tokens, sup_tokens, embeddings), dim=1)
        else:
            embeddings = torch.cat((cls_tokens, embeddings), dim=1)

        # add positional encoding to each token
        if interpolate_pos_encoding:
            embeddings = embeddings + self.interpolate_pos_encoding(embeddings, height, width)
        else:
            embeddings = embeddings + self.position_embeddings

        embeddings = self.dropout(embeddings)

        return embeddings


class ViTRDPatchEmbeddings(nn.Module):
    """
    This class turns `pixel_values` of shape `(batch_size, num_channels, height, width)` into the initial
    `hidden_states` (patch embeddings) of shape `(batch_size, seq_length, hidden_size)` to be consumed by a
    Transformer.
    """

    def __init__(self, config: ViTRDConfig):
        super().__init__()
        image_size, patch_size = config.image_size, config.patch_size
        num_channels, hidden_size = config.num_channels, config.hidden_size

        image_size = image_size if isinstance(image_size, collections.abc.Iterable) else (image_size, image_size)
        patch_size = patch_size if isinstance(patch_size, collections.abc.Iterable) else (patch_size, patch_size)
        num_patches = (image_size[1] // patch_size[1]) * (image_size[0] // patch_size[0])
        self.image_size = image_size
        self.patch_size = patch_size
        self.num_channels = num_channels
        self.num_patches = num_patches

        self.projection = nn.Conv2d(num_channels, hidden_size, kernel_size=patch_size, stride=patch_size)

    def forward(self, pixel_values: torch.Tensor, interpolate_pos_encoding: bool = False) -> torch.Tensor:
        batch_size, num_channels, height, width = pixel_values.shape
        if num_channels != self.num_channels:
            raise ValueError(
                "Make sure that the channel dimension of the pixel values match with the one set in the configuration."
                f" Expected {self.num_channels} but got {num_channels}."
            )
        if not interpolate_pos_encoding:
            if height != self.image_size[0] or width != self.image_size[1]:
                raise ValueError(
                    f"Input image size ({height}*{width}) doesn't match model"
                    f" ({self.image_size[0]}*{self.image_size[1]})."
                )
        embeddings = self.projection(pixel_values).flatten(2).transpose(1, 2)
        return embeddings


def eager_attention_forward(
    module: nn.Module,
    query: torch.Tensor,
    key: torch.Tensor,
    value: torch.Tensor,
    attention_mask: Optional[torch.Tensor],
    scaling: float,
    dropout: float = 0.0,
    **kwargs,
):
    # Take the dot product between "query" and "key" to get the raw attention scores.
    attn_weights = torch.matmul(query, key.transpose(-1, -2)) * scaling

    # Normalize the attention scores to probabilities.
    attn_weights = nn.functional.softmax(attn_weights, dim=-1, dtype=torch.float32).to(query.dtype)

    # This is actually dropping out entire tokens to attend to, which might
    # seem a bit unusual, but is taken from the original Transformer paper.
    attn_weights = nn.functional.dropout(attn_weights, p=dropout, training=module.training)

    # Mask heads if we want to
    if attention_mask is not None:
        attn_weights = attn_weights * attention_mask

    attn_output = torch.matmul(attn_weights, value)
    attn_output = attn_output.transpose(1, 2).contiguous()

    return attn_output, attn_weights


class ViTRDSelfAttention(nn.Module):
    def __init__(self, config: ViTRDConfig):
        super().__init__()
        if config.hidden_size % config.num_attention_heads != 0 and not hasattr(config, "embedding_size"):
            raise ValueError(
                f"The hidden size {config.hidden_size} is not a multiple of the number of attention "
                f"heads {config.num_attention_heads}."
            )

        self.config = config
        self.num_attention_heads = config.num_attention_heads
        self.attention_head_size = int(config.hidden_size / config.num_attention_heads)
        self.all_head_size = self.num_attention_heads * self.attention_head_size
        self.dropout_prob = config.attention_probs_dropout_prob
        self.scaling = self.attention_head_size**-0.5
        self.is_causal = False

        self.query = nn.Linear(config.hidden_size, self.all_head_size, bias=config.qkv_bias)
        self.key = nn.Linear(config.hidden_size, self.all_head_size, bias=config.qkv_bias)
        self.value = nn.Linear(config.hidden_size, self.all_head_size, bias=config.qkv_bias)

    def forward(
        self,
        hidden_states: torch.Tensor,
        head_mask: Optional[torch.Tensor] = None,
    ) -> tuple[torch.Tensor, torch.Tensor]:
        batch_size = hidden_states.shape[0]
        new_shape = batch_size, -1, self.num_attention_heads, self.attention_head_size

        key_layer = self.key(hidden_states).view(*new_shape).transpose(1, 2)
        value_layer = self.value(hidden_states).view(*new_shape).transpose(1, 2)
        query_layer = self.query(hidden_states).view(*new_shape).transpose(1, 2)

        attention_interface: Callable = eager_attention_forward
        # EViT need attention_probs for token dropping
        if os.environ.get("EViT") in ("0", None, ""):
            if self.config._attn_implementation != "eager":
                attention_interface = ALL_ATTENTION_FUNCTIONS[self.config._attn_implementation]

        context_layer, attention_probs = attention_interface(
            self,
            query_layer,
            key_layer,
            value_layer,
            head_mask,
            is_causal=self.is_causal,
            scaling=self.scaling,
            dropout=0.0 if not self.training else self.dropout_prob,
        )

        new_context_layer_shape = context_layer.size()[:-2] + (self.all_head_size,)
        context_layer = context_layer.reshape(new_context_layer_shape)

        return context_layer, attention_probs


class ViTRDSelfOutput(nn.Module):
    """
    The residual connection is defined in ViTRDLayer instead of here (as is the case with other models), due to the
    layernorm applied before each block.
    """

    def __init__(self, config: ViTRDConfig):
        super().__init__()
        self.dense = nn.Linear(config.hidden_size, config.hidden_size)
        self.dropout = nn.Dropout(config.hidden_dropout_prob)

    def forward(self, hidden_states: torch.Tensor, input_tensor: torch.Tensor) -> torch.Tensor:
        hidden_states = self.dense(hidden_states)
        hidden_states = self.dropout(hidden_states)
        return hidden_states


class ViTRDAttention(nn.Module):
    def __init__(self, config: ViTRDConfig):
        super().__init__()
        self.attention = ViTRDSelfAttention(config)
        self.output = ViTRDSelfOutput(config)
        self.pruned_heads = set()

    def prune_heads(self, heads: set[int]):
        if len(heads) == 0:
            return
        heads, index = find_pruneable_heads_and_indices(
            heads, self.attention.num_attention_heads, self.attention.attention_head_size, self.pruned_heads
        )

        # Prune linear layers
        self.attention.query = prune_linear_layer(self.attention.query, index)
        self.attention.key = prune_linear_layer(self.attention.key, index)
        self.attention.value = prune_linear_layer(self.attention.value, index)
        self.output.dense = prune_linear_layer(self.output.dense, index, dim=1)

        # Update hyper params and store pruned heads
        self.attention.num_attention_heads = self.attention.num_attention_heads - len(heads)
        self.attention.all_head_size = self.attention.attention_head_size * self.attention.num_attention_heads
        self.pruned_heads = self.pruned_heads.union(heads)

    def forward(
        self,
        hidden_states: torch.Tensor,
        head_mask: Optional[torch.Tensor] = None,
    ) -> torch.Tensor:
        self_attn_output, self_attn_probs = self.attention(hidden_states, head_mask)
        output = self.output(self_attn_output, hidden_states)
        return output, self_attn_probs


class ViTRDIntermediate(nn.Module):
    def __init__(self, config: ViTRDConfig):
        super().__init__()
        self.dense = nn.Linear(config.hidden_size, config.intermediate_size)
        if isinstance(config.hidden_act, str):
            self.intermediate_act_fn = ACT2FN[config.hidden_act]
        else:
            self.intermediate_act_fn = config.hidden_act

    def forward(self, hidden_states: torch.Tensor) -> torch.Tensor:
        hidden_states = self.dense(hidden_states)
        hidden_states = self.intermediate_act_fn(hidden_states)
        return hidden_states


class ViTRDOutput(nn.Module):
    def __init__(self, config: ViTRDConfig):
        super().__init__()
        self.dense = nn.Linear(config.intermediate_size, config.hidden_size)
        self.dropout = nn.Dropout(config.hidden_dropout_prob)

    def forward(self, hidden_states: torch.Tensor, input_tensor: torch.Tensor) -> torch.Tensor:
        hidden_states = self.dense(hidden_states)
        hidden_states = self.dropout(hidden_states)
        hidden_states = hidden_states + input_tensor
        return hidden_states


class ViTRDLayer(GradientCheckpointingLayer):
    """This corresponds to the Block class in the timm implementation."""

    def __init__(self, config: ViTRDConfig):
        super().__init__()
        self.config = config
        self.chunk_size_feed_forward = config.chunk_size_feed_forward
        self.seq_len_dim = 1
        self.attention = ViTRDAttention(config)
        self.intermediate = ViTRDIntermediate(config)
        self.output = ViTRDOutput(config)
        self.layernorm_before = nn.LayerNorm(config.hidden_size, eps=config.layer_norm_eps)
        self.layernorm_after = nn.LayerNorm(config.hidden_size, eps=config.layer_norm_eps)

    def _evit(
        self,
        hidden_states: torch.Tensor,
        cls_attention_probs: torch.Tensor,
        keep_ratio: float=0.1,
        fuse_token: bool=False,
    ) -> torch.Tensor:
        """
        Implements EViT token pruning based on cls attention scores.
        Args:
            hidden_states (torch.Tensor): The input hidden states of shape [B, N, C].
            cls_attention_probs (torch.Tensor): The cls attention scores of shape [B, H, N - 1 - sup_token].
            keep_ratio (float): The ratio of tokens to keep based on cls attention scores.
            fuse_token (bool): Whether to fuse the pruned tokens into the new extra token.
        Returns:
            torch.Tensor: The pruned hidden states.
        """
        keep_len = round(keep_ratio * cls_attention_probs.shape[-1])
        if keep_len == cls_attention_probs.shape[-1] or keep_len == 0:
            return hidden_states

        # [B, H, N - 1 - sup_token]
        cls_attention_probs = cls_attention_probs.mean(dim=1)
        # [B, keep_len]
        keep_indices = torch.topk(cls_attention_probs, keep_len, dim=1, largest=True).indices
        head_token_len = hidden_states.shape[1] - cls_attention_probs.shape[-1]
        keep_indices_real = keep_indices + head_token_len
        # [B, cls + sup + keep_len]
        keep_indices_real = torch.cat(
            (
                torch.arange(head_token_len, device=hidden_states.device).unsqueeze(0).expand(hidden_states.shape[0], -1),
                keep_indices_real,
            ),
            dim=1,
        )
        keep_indices_real = keep_indices_real.sort(dim=1).values

        output_hidden_states = torch.gather(
            hidden_states,
            dim=1,
            index=keep_indices_real.unsqueeze(-1).expand(-1, -1, hidden_states.shape[-1]),
        )

        if fuse_token is False:
            return output_hidden_states

        all_indices = torch.arange(
            cls_attention_probs.shape[1],
            device=hidden_states.device
        ).unsqueeze(0).expand(cls_attention_probs.shape[0], -1)
        marker = torch.full_like(all_indices, fill_value=0, device=hidden_states.device)
        marker.scatter_(dim=1, index=keep_indices, value=-1)
        prune_mask = marker != -1
        # [B, prune_len]
        prune_indices = all_indices[prune_mask].view(keep_indices.shape[0], -1)
        # [B, prune_len, C]
        prune_token = torch.gather(
            hidden_states[:, head_token_len:, :],
            dim=1,
            index=prune_indices.unsqueeze(-1).expand(-1, -1, hidden_states.shape[-1]),
        )
        prune_attention_probs = torch.gather(
            cls_attention_probs,
            dim=1,
            index=prune_indices,
        )
        extra_token = torch.sum(
            prune_token * prune_attention_probs.unsqueeze(-1),
            dim=1,
            keepdim=True,
        )
        return torch.cat([output_hidden_states, extra_token], dim=1)

    def forward(
        self,
        hidden_states: torch.Tensor,
        head_mask: Optional[torch.Tensor] = None,
        output_attentions: bool = False,
    ) -> torch.Tensor:
        hidden_states_norm = self.layernorm_before(hidden_states)
        attention_output, attention_probs = self.attention(hidden_states_norm, head_mask)

        # first residual connection
        hidden_states = attention_output + hidden_states

        # EViT
        if os.environ.get("EViT") not in ("0", None, "") and output_attentions is True:
            # cls attentions [B, H, N - 1 - sup_token]
            if self.config.supplement_token is not None:
                if isinstance(self.config.supplement_token, int):
                    cls_attention_probs = attention_probs[:, :, 0, 1 + self.config.supplement_token:]
                elif self.config.supplement_token == 'layerwise1':
                    cls_attention_probs = attention_probs[:, :, 0, 1 + self.config.num_hidden_layers:]
                elif self.config.supplement_token == 'layerwise2':
                    cls_attention_probs = attention_probs[:, :, 0, 1 + self.config.num_hidden_layers * 2:]
            hidden_states = self._evit(
                hidden_states=hidden_states,
                cls_attention_probs=cls_attention_probs,
                keep_ratio=round(float(os.environ.get("EViT")), 2),
                fuse_token=True,
            )

        # in ViTRD, layernorm is also applied after self-attention
        layer_output = self.layernorm_after(hidden_states)
        layer_output = self.intermediate(layer_output)

        # second residual connection is done here
        layer_output = self.output(layer_output, hidden_states)

        return layer_output


class ViTRDEncoder(nn.Module):
    def __init__(self, config: ViTRDConfig):
        super().__init__()
        self.config = config
        self.layer = nn.ModuleList([ViTRDLayer(config) for _ in range(config.num_hidden_layers)])
        self.gradient_checkpointing = False

    def _random_discard(
        self,
        hidden_states: torch.Tensor,
        ignored_mask: Optional[torch.Tensor] = None,
        discard_rate: Optional[float] = None,
        seed: Optional[int] = None,
    ) -> torch.Tensor:
        """
        Randomly discard a portion of tokens during training for efficiency,
        excluding tokens in `ignored_mask`.
        """
        if not discard_rate or discard_rate <= 0.0:
            return hidden_states

        batch_size, seq_len, _ = hidden_states.shape
        device = hidden_states.device

         # Mask for candidate indices (non-ignored tokens)
        if ignored_mask is None:
            candidate_mask = torch.ones(seq_len, dtype=torch.bool, device=device)
            ignored_indices = (
                torch.tensor([], dtype=torch.long, device=device)
                .unsqueeze(0)
                .expand(batch_size, -1)
            )
        else:
            candidate_mask = ~ignored_mask
            ignored_indices = (
                ignored_mask.nonzero(as_tuple=True)[0]
                .unsqueeze(0)
                .repeat(batch_size, 1)
            )
        candidate_indices = (
            torch.arange(seq_len, device=device)
            .unsqueeze(0)
            .repeat(batch_size, 1)[:, candidate_mask]
        )
        candidate_len = candidate_indices.shape[1]
        keep_len = round(candidate_len * (1.0 - discard_rate))

        # Randomly shuffle candidate indices for each sample in the batch
        rand_indices = torch.rand(
            batch_size,
            candidate_len,
            generator=torch.Generator(device=device).manual_seed(seed) if seed else None,
            device=device,
        ).argsort(dim=-1)
        # Select indices to keep
        keep_indices = rand_indices[:, :keep_len]
        # Map selected indices to the original sequence
        keep_indices = torch.gather(candidate_indices, dim=1, index=keep_indices)
        # Add ignored indices (e.g., CLS token) to the keep indices
        keep_indices = torch.cat([ignored_indices, keep_indices], dim=-1)

        # Gather the tokens based on the keep indices
        batch_indices = torch.arange(batch_size, device=device).unsqueeze(1)
        hidden_states = hidden_states[batch_indices, keep_indices, :]

        return hidden_states

    def _divprune_token_choose(
        self,
        visual_hidden_states: torch.Tensor,
        visual_token_len: int,
        keep_ratio: float=0.1,
    ):
        """
        Diversity Pruning Implementation.

        Args:
            visual_hidden_states (torch.Tensor): The visual feature vectors to be pruned.
            visual_token_len (int): The length of the image feature vectors.
            keep_ratio (float): The ratio of features to keep based on diversity pruning.
        """
        def _pairwise_cosine_similarity(hidden_states: torch.Tensor) -> torch.Tensor:
            # hidden_states (batch_size, num_patches, feature_dim)
            norm_hidden_states = hidden_states / (hidden_states.norm(dim=-1, keepdim=True) + 1e-8)
            cosine_matrix = torch.matmul(norm_hidden_states, norm_hidden_states.transpose(1, 2))

            # cosine_matrix (batch_size, num_patches, num_patches)
            return cosine_matrix

        # make sure keep len is an integer
        keep_len = int(round(keep_ratio * visual_token_len))
        # the closer to 0, the more similar
        cosine_matrix = 1.0 - (_pairwise_cosine_similarity(visual_hidden_states))

        s = torch.empty(
            visual_hidden_states.shape[0],
            keep_len,
            dtype=torch.long,
            device=visual_hidden_states.device
        )
        for i in range(keep_len):
            if i == 0:
                m2 = cosine_matrix
            else:
                s_expanded = s.unsqueeze(-1).expand(-1, -1, cosine_matrix.size(2))
                m2 = torch.gather(cosine_matrix, dim=1, index=s_expanded[:, :i, :])

            # Step1: DivPrune requires selecting the token[j] that is most similar to each token[i].
            if i == 0:
                # dim = 1 (select the top2 in each column of each batch)ï¼Œlargest=False (choose the least)
                # torch.top2 (batch_size, 2, num_patches)
                # values[:, 1, :] (batch_size, num_patches)
                scores = torch.topk(m2, 2, dim=1, largest=False).values[:, 1, :]
            else:
                # get the minimal similarity score to selected token set (s) for each token
                scores = torch.min(m2, dim=1).values

            # Step2: choose the maximal score of scores (find the least similar among the most similar)
            s[:, i] = torch.argmax(scores, dim=1)

        return s

    def _divprune(
        self,
        hidden_states: torch.Tensor,
        head_token_len: int,
        keep_ratio: float,
    ):
        if keep_ratio == None or keep_ratio >= 1.0 or keep_ratio <= 0.0:
            return hidden_states

        if head_token_len == None:
            head_token_len = 0

        # what is returned is the "index" of the retained visual token
        keep_indices = self._divprune_token_choose(
            hidden_states[:, head_token_len:, :],
            int(hidden_states.shape[1] - head_token_len),
            keep_ratio,
        )

        # add offset head_token_len to get the real index in hidden_states
        keep_indices += head_token_len
        keep_indices = torch.cat(
            (
                torch.arange(head_token_len, device=hidden_states.device).unsqueeze(0).expand(keep_indices.size(0), -1),
                keep_indices,
            ),
            dim=1,
        )
        keep_indices = keep_indices.sort(dim=1).values
        keep_indices = keep_indices.unsqueeze(-1).expand(-1, -1, hidden_states.shape[-1])

        return torch.gather(hidden_states, dim=1, index=keep_indices)

    def forward(
        self,
        hidden_states: torch.Tensor,
        head_mask: Optional[torch.Tensor] = None,
        discard_rate: Optional[float] = None,
        discard_before_layers: Optional[List[bool]] = None,
        seed: Optional[int] = None,
    ) -> BaseModelOutput:
        head_token_len = 1
        if self.config.supplement_token is not None:
            if isinstance(self.config.supplement_token, int):
                head_token_len += self.config.supplement_token
            elif self.config.supplement_token == 'layerwise1':
                head_token_len += self.config.num_hidden_layers
            elif self.config.supplement_token == 'layerwise2':
                head_token_len += self.config.num_hidden_layers * 2
        if os.environ.get("DIVPRUNE"):
            keep_ratio = round(float(os.environ.get("DIVPRUNE")), 2)
            hidden_states = self._divprune(
                hidden_states=hidden_states,
                head_token_len=head_token_len,
                keep_ratio=keep_ratio,
            )

        for i, layer_module in enumerate(self.layer):
            if (
                discard_rate is not None
                and discard_before_layers is not None
                and len(discard_before_layers) == self.config.num_hidden_layers
                and discard_rate > 0.0
                and discard_rate < 1.0
                and discard_before_layers[i]
            ):
                ignored_mask = torch.zeros(
                    hidden_states.shape[1],
                    dtype=torch.bool,
                    device=hidden_states.device
                )
                if self.config.supplement_token is not None:
                    if isinstance(self.config.supplement_token, int):
                        ignored_mask[: 1 + self.config.supplement_token] = True
                    elif self.config.supplement_token == 'layerwise1':
                        ignored_mask[: 1 + self.config.num_hidden_layers] = True
                    elif self.config.supplement_token == 'layerwise2':
                        ignored_mask[: 1 + self.config.num_hidden_layers * 2] = True
                else:
                    ignored_mask[0] = True
                hidden_states = self._random_discard(
                    hidden_states=hidden_states,
                    ignored_mask=ignored_mask,
                    discard_rate=discard_rate,
                    seed=seed,
                )

            sup_mask = torch.ones_like(hidden_states, device=hidden_states.device)
            if self.config.supplement_token == 'layerwise1':
                sup_mask[:, 1 : 1 + self.config.num_hidden_layers, :] = 0
                sup_mask[:, 1 + i, :] = 1
            elif self.config.supplement_token == 'layerwise2':
                sup_mask[:, 1 : 1 + self.config.num_hidden_layers * 2, :] = 0
                sup_mask[:, 1 + i * 2 : 3 + i * 2, :] = 1

            masked_hidden_states = hidden_states * sup_mask
            layer_head_mask = head_mask[i] if head_mask is not None else None
            if os.environ.get("EViT") not in ("0", None, "") and i in (3, 6, 9):
                masked_hidden_states = layer_module(masked_hidden_states, layer_head_mask, True)
                sup_mask = sup_mask[:, : masked_hidden_states.shape[1], :]
                hidden_states = hidden_states[:, : masked_hidden_states.shape[1], :]
            else:
                masked_hidden_states = layer_module(masked_hidden_states, layer_head_mask, False)
            hidden_states = masked_hidden_states + (1 - sup_mask) * hidden_states

        return BaseModelOutput(last_hidden_state=hidden_states)


@auto_docstring
class ViTRDPreTrainedModel(PreTrainedModel):
    config: ViTRDConfig
    base_model_prefix = "vit_rd"
    main_input_name = "pixel_values"
    supports_gradient_checkpointing = True
    _no_split_modules = ["ViTRDEmbeddings", "ViTRDLayer"]
    _supports_sdpa = True
    _supports_flash_attn = True
    _supports_flex_attn = True
    _supports_attention_backend = True
    _can_record_outputs = {
        "hidden_states": ViTRDLayer,
        "attentions": ViTRDSelfAttention,
    }

    def _init_weights(self, module: Union[nn.Linear, nn.Conv2d, nn.LayerNorm]):
        """Initialize the weights"""
        if isinstance(module, (nn.Linear, nn.Conv2d)):
            # Upcast the input in `fp32` and cast it back to desired `dtype` to avoid
            # `trunc_normal_cpu` not implemented in `half` issues
            module.weight.data = nn.init.trunc_normal_(
                module.weight.data.to(torch.float32), mean=0.0, std=self.config.initializer_range
            ).to(module.weight.dtype)
            if module.bias is not None:
                module.bias.data.zero_()
        elif isinstance(module, nn.LayerNorm):
            module.bias.data.zero_()
            module.weight.data.fill_(1.0)
        elif isinstance(module, ViTRDEmbeddings):
            module.position_embeddings.data = nn.init.trunc_normal_(
                module.position_embeddings.data.to(torch.float32),
                mean=0.0,
                std=self.config.initializer_range,
            ).to(module.position_embeddings.dtype)

            module.cls_token.data = nn.init.trunc_normal_(
                module.cls_token.data.to(torch.float32),
                mean=0.0,
                std=self.config.initializer_range,
            ).to(module.cls_token.dtype)

            if hasattr(module, "sup_token"):
                module.sup_token.data = nn.init.trunc_normal_(
                    module.sup_token.data.to(torch.float32),
                    mean=0.0,
                    std=self.config.initializer_range,
                ).to(module.sup_token.dtype)

            if module.mask_token is not None:
                module.mask_token.data.zero_()


@auto_docstring
class ViTRDModel(ViTRDPreTrainedModel):
    def __init__(self, config: ViTRDConfig, add_pooling_layer: bool = True, use_mask_token: bool = False):
        r"""
        add_pooling_layer (bool, *optional*, defaults to `True`):
            Whether to add a pooling layer
        use_mask_token (`bool`, *optional*, defaults to `False`):
            Whether to use a mask token for masked image modeling.
        """
        super().__init__(config)
        self.config = config

        self.embeddings = ViTRDEmbeddings(config, use_mask_token=use_mask_token)
        self.encoder = ViTRDEncoder(config)

        self.layernorm = nn.LayerNorm(config.hidden_size, eps=config.layer_norm_eps)
        self.pooler = ViTRDPooler(config) if add_pooling_layer else None

        # Initialize weights and apply final processing
        self.post_init()

    def get_input_embeddings(self) -> ViTRDPatchEmbeddings:
        return self.embeddings.patch_embeddings

    def _prune_heads(self, heads_to_prune: dict[int, list[int]]):
        """
        Prunes heads of the model. heads_to_prune: dict of {layer_num: list of heads to prune in this layer} See base
        class PreTrainedModel
        """
        for layer, heads in heads_to_prune.items():
            self.encoder.layer[layer].attention.prune_heads(heads)

    @check_model_inputs(tie_last_hidden_states=False)
    @auto_docstring
    def forward(
        self,
        pixel_values: Optional[torch.Tensor] = None,
        bool_masked_pos: Optional[torch.BoolTensor] = None,
        head_mask: Optional[torch.Tensor] = None,
        interpolate_pos_encoding: Optional[bool] = None,
        discard_rate: Optional[float] = None,
        discard_before_layers: Optional[List[bool]] = None,
        seed: Optional[int] = None,
        **kwargs: Unpack[TransformersKwargs],
    ) -> BaseModelOutputWithPooling:
        r"""
        bool_masked_pos (`torch.BoolTensor` of shape `(batch_size, num_patches)`, *optional*):
            Boolean masked positions. Indicates which patches are masked (1) and which aren't (0).
        discard_rate (`float`, *optional*):
            The rate of tokens to randomly discard during training for efficiency.
        discard_before_layers (`List[bool]`, *optional*):
            Indicates which layers the tokens are discarded before.
        seed (`int`, *optional*):
            Random seed for token discarding.
        """

        if pixel_values is None:
            raise ValueError("You have to specify pixel_values")

        # Prepare head mask if needed
        # 1.0 in head_mask indicate we keep the head
        # attention_probs has shape bsz x n_heads x N x N
        # input head_mask has shape [num_heads] or [num_hidden_layers x num_heads]
        # and head_mask is converted to shape [num_hidden_layers x batch x num_heads x seq_length x seq_length]
        head_mask = self.get_head_mask(head_mask, self.config.num_hidden_layers)

        # TODO: maybe have a cleaner way to cast the input (from `ImageProcessor` side?)
        expected_dtype = self.embeddings.patch_embeddings.projection.weight.dtype
        if pixel_values.dtype != expected_dtype:
            pixel_values = pixel_values.to(expected_dtype)

        embedding_output = self.embeddings(
            pixel_values, bool_masked_pos=bool_masked_pos, interpolate_pos_encoding=interpolate_pos_encoding
        )

        encoder_outputs: BaseModelOutput = self.encoder(
            embedding_output,
            head_mask=head_mask,
            discard_rate=discard_rate,
            discard_before_layers=discard_before_layers,
            seed=seed,
        )

        sequence_output = encoder_outputs.last_hidden_state
        sequence_output = self.layernorm(sequence_output)
        pooled_output = self.pooler(sequence_output) if self.pooler is not None else None

        return BaseModelOutputWithPooling(last_hidden_state=sequence_output, pooler_output=pooled_output)


class ViTRDPooler(nn.Module):
    def __init__(self, config: ViTRDConfig):
        super().__init__()
        self.dense = nn.Linear(config.hidden_size, config.pooler_output_size)
        self.activation = ACT2FN[config.pooler_act]

    def forward(self, hidden_states: torch.Tensor) -> torch.Tensor:
        # We "pool" the model by simply taking the hidden state corresponding
        # to the first token.
        first_token_tensor = hidden_states[:, 0]
        pooled_output = self.dense(first_token_tensor)
        pooled_output = self.activation(pooled_output)
        return pooled_output


@auto_docstring(
    custom_intro="""
    ViTRD Model with a decoder on top for masked image modeling, as proposed in [SimMIM](https://huggingface.co/papers/2111.09886).

    <Tip>

    Note that we provide a script to pre-train this model on custom data in our [examples
    directory](https://github.com/huggingface/transformers/tree/main/examples/pytorch/image-pretraining).

    </Tip>
    """
)
class ViTRDForMaskedImageModeling(ViTRDPreTrainedModel):
    def __init__(self, config: ViTRDConfig):
        super().__init__(config)

        self.vit = ViTRDModel(config, add_pooling_layer=False, use_mask_token=True)

        self.decoder = nn.Sequential(
            nn.Conv2d(
                in_channels=config.hidden_size,
                out_channels=config.encoder_stride**2 * config.num_channels,
                kernel_size=1,
            ),
            nn.PixelShuffle(config.encoder_stride),
        )

        # Initialize weights and apply final processing
        self.post_init()

    @can_return_tuple
    @auto_docstring
    def forward(
        self,
        pixel_values: Optional[torch.Tensor] = None,
        bool_masked_pos: Optional[torch.BoolTensor] = None,
        head_mask: Optional[torch.Tensor] = None,
        interpolate_pos_encoding: Optional[bool] = None,
        **kwargs: Unpack[TransformersKwargs],
    ) -> MaskedImageModelingOutput:
        r"""
        bool_masked_pos (`torch.BoolTensor` of shape `(batch_size, num_patches)`):
            Boolean masked positions. Indicates which patches are masked (1) and which aren't (0).

        Examples:
        ```python
        >>> from transformers import AutoImageProcessor, ViTRDForMaskedImageModeling
        >>> import torch
        >>> from PIL import Image
        >>> import requests

        >>> url = "http://images.cocodataset.org/val2017/000000039769.jpg"
        >>> image = Image.open(requests.get(url, stream=True).raw)

        >>> image_processor = AutoImageProcessor.from_pretrained("google/vit_rd-base-patch16-224-in21k")
        >>> model = ViTRDForMaskedImageModeling.from_pretrained("google/vit_rd-base-patch16-224-in21k")

        >>> num_patches = (model.config.image_size // model.config.patch_size) ** 2
        >>> pixel_values = image_processor(images=image, return_tensors="pt").pixel_values
        >>> # create random boolean mask of shape (batch_size, num_patches)
        >>> bool_masked_pos = torch.randint(low=0, high=2, size=(1, num_patches)).bool()

        >>> outputs = model(pixel_values, bool_masked_pos=bool_masked_pos)
        >>> loss, reconstructed_pixel_values = outputs.loss, outputs.reconstruction
        >>> list(reconstructed_pixel_values.shape)
        [1, 3, 224, 224]
        ```"""

        if bool_masked_pos is not None and (self.config.patch_size != self.config.encoder_stride):
            raise ValueError(
                "When `bool_masked_pos` is provided, `patch_size` must be equal to `encoder_stride` to ensure that "
                "the reconstructed image has the same dimensions as the input. "
                f"Got `patch_size` = {self.config.patch_size} and `encoder_stride` = {self.config.encoder_stride}."
            )

        outputs: BaseModelOutputWithPooling = self.vit(
            pixel_values,
            bool_masked_pos=bool_masked_pos,
            head_mask=head_mask,
            interpolate_pos_encoding=interpolate_pos_encoding,
            **kwargs,
        )

        sequence_output = outputs.last_hidden_state

        # Reshape to (batch_size, num_channels, height, width)
        sequence_output = sequence_output[:, 1:]
        batch_size, sequence_length, num_channels = sequence_output.shape
        height = width = math.floor(sequence_length**0.5)
        sequence_output = sequence_output.permute(0, 2, 1).reshape(batch_size, num_channels, height, width)

        # Reconstruct pixel values
        reconstructed_pixel_values = self.decoder(sequence_output)

        masked_im_loss = None
        if bool_masked_pos is not None:
            size = self.config.image_size // self.config.patch_size
            bool_masked_pos = bool_masked_pos.reshape(-1, size, size)
            mask = (
                bool_masked_pos.repeat_interleave(self.config.patch_size, 1)
                .repeat_interleave(self.config.patch_size, 2)
                .unsqueeze(1)
                .contiguous()
            )
            reconstruction_loss = nn.functional.l1_loss(pixel_values, reconstructed_pixel_values, reduction="none")
            masked_im_loss = (reconstruction_loss * mask).sum() / (mask.sum() + 1e-5) / self.config.num_channels

        return MaskedImageModelingOutput(
            loss=masked_im_loss,
            reconstruction=reconstructed_pixel_values,
            hidden_states=outputs.hidden_states,
            attentions=outputs.attentions,
        )


@auto_docstring(
    custom_intro="""
    ViTRD Model transformer with an image classification head on top (a linear layer on top of the final hidden state of
    the [CLS] token) e.g. for ImageNet.

    <Tip>

        Note that it's possible to fine-tune ViTRD on higher resolution images than the ones it has been trained on, by
        setting `interpolate_pos_encoding` to `True` in the forward of the model. This will interpolate the pre-trained
        position embeddings to the higher resolution.

    </Tip>
    """
)
class ViTRDForImageClassification(ViTRDPreTrainedModel):
    def __init__(self, config: ViTRDConfig):
        super().__init__(config)

        self.num_labels = config.num_labels
        self.vit = ViTRDModel(config, add_pooling_layer=False)

        # Classifier head
        self.classifier = nn.Linear(config.hidden_size, config.num_labels) if config.num_labels > 0 else nn.Identity()

        # Initialize weights and apply final processing
        self.post_init()

    @can_return_tuple
    @auto_docstring
    def forward(
        self,
        pixel_values: Optional[torch.Tensor] = None,
        head_mask: Optional[torch.Tensor] = None,
        labels: Optional[torch.Tensor] = None,
        interpolate_pos_encoding: Optional[bool] = None,
        discard_rate: Optional[float] = None,
        discard_before_layers: Optional[List[bool]] = None,
        seed: Optional[int] = None,
        **kwargs: Unpack[TransformersKwargs],
    ) -> ImageClassifierOutput:
        r"""
        labels (`torch.LongTensor` of shape `(batch_size,)`, *optional*):
            Labels for computing the image classification/regression loss. Indices should be in `[0, ...,
            config.num_labels - 1]`. If `config.num_labels == 1` a regression loss is computed (Mean-Square loss), If
            `config.num_labels > 1` a classification loss is computed (Cross-Entropy).
        discard_rate (`float`, *optional*):
            The rate of tokens to randomly discard during training for efficiency.
        discard_before_layers (`List[bool]`, *optional*):
            Indicates which layers the tokens are discarded before.
        seed (`int`, *optional*):
            Random seed for token discarding.
        """

        outputs: BaseModelOutputWithPooling = self.vit(
            pixel_values,
            head_mask=head_mask,
            interpolate_pos_encoding=interpolate_pos_encoding,
            discard_rate=discard_rate,
            discard_before_layers=discard_before_layers,
            seed=seed,
            **kwargs,
        )

        sequence_output = outputs.last_hidden_state
        pooled_output = sequence_output[:, 0, :]
        logits = self.classifier(pooled_output)

        loss = None
        if labels is not None:
            loss = self.loss_function(labels, logits, self.config, **kwargs)

        return ImageClassifierOutput(
            loss=loss,
            logits=logits,
            hidden_states=outputs.hidden_states,
            attentions=outputs.attentions,
        )


__all__ = ["ViTRDForImageClassification", "ViTRDForMaskedImageModeling", "ViTRDModel", "ViTRDPreTrainedModel"]
